<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 深拷贝
    // 注意：
    // 1.深拷贝JSON.parse的问题
    // 1）如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式
    // 2）如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；
    // 3）如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；
    // 4）如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null
    // 5）JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；
    // 6）如果对象中存在循环引用的情况也无法正确实现深拷贝；
    // 2.赋值于深拷贝的区别：
    // 赋值：值会跟着改变
    // 浅拷贝：基本类型已经脱离，但是复杂的类型还会跟着改变
    // function deepClone(obj) {
    //   var cloneObj = {}

    //   if (obj === null) return obj
    //   if (obj instanceof Date) return new Date(obj)
    //   if (obj instanceof RegExp) return new RegExp(obj)
    //   if (typeof obj !== 'object') return obj
    //   for (var i in obj) {
    //     if (obj.hasOwnProperty(i)) {
    //       cloneObj[i] = deepClone(obj[i])
    //     }
    //   }
    //   return cloneObj
    // }

    // var obj = {
    //   name: '张三',
    //   car: ['奥迪']
    // }

    // var obj1 = deepClone(obj)
    // obj1.car[0] = '奥拓'

    // console.log(obj)
    // console.log(obj1)
  </script>
</body>

</html>